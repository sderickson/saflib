// @ts-nocheck
/**
 * Generated by the protoc-gen-ts.  DO NOT EDIT!
 * compiler version: 5.29.3
 * source: health/index.proto
 * git: https://github.com/thesayyn/protoc-gen-ts */
import * as dependency_1 from "./get-health.ts";
import * as grpc_1 from "@grpc/grpc-js";
interface GrpcUnaryServiceInterface<P, R> {
  (
    message: P,
    metadata: grpc_1.Metadata,
    options: grpc_1.CallOptions,
    callback: grpc_1.requestCallback<R>,
  ): grpc_1.ClientUnaryCall;
  (
    message: P,
    metadata: grpc_1.Metadata,
    callback: grpc_1.requestCallback<R>,
  ): grpc_1.ClientUnaryCall;
  (
    message: P,
    options: grpc_1.CallOptions,
    callback: grpc_1.requestCallback<R>,
  ): grpc_1.ClientUnaryCall;
  (message: P, callback: grpc_1.requestCallback<R>): grpc_1.ClientUnaryCall;
}
interface GrpcStreamServiceInterface<P, R> {
  (
    message: P,
    metadata: grpc_1.Metadata,
    options?: grpc_1.CallOptions,
  ): grpc_1.ClientReadableStream<R>;
  (message: P, options?: grpc_1.CallOptions): grpc_1.ClientReadableStream<R>;
}
interface GrpWritableServiceInterface<P, R> {
  (
    metadata: grpc_1.Metadata,
    options: grpc_1.CallOptions,
    callback: grpc_1.requestCallback<R>,
  ): grpc_1.ClientWritableStream<P>;
  (
    metadata: grpc_1.Metadata,
    callback: grpc_1.requestCallback<R>,
  ): grpc_1.ClientWritableStream<P>;
  (
    options: grpc_1.CallOptions,
    callback: grpc_1.requestCallback<R>,
  ): grpc_1.ClientWritableStream<P>;
  (callback: grpc_1.requestCallback<R>): grpc_1.ClientWritableStream<P>;
}
interface GrpcChunkServiceInterface<P, R> {
  (
    metadata: grpc_1.Metadata,
    options?: grpc_1.CallOptions,
  ): grpc_1.ClientDuplexStream<P, R>;
  (options?: grpc_1.CallOptions): grpc_1.ClientDuplexStream<P, R>;
}
interface GrpcPromiseServiceInterface<P, R> {
  (
    message: P,
    metadata: grpc_1.Metadata,
    options?: grpc_1.CallOptions,
  ): Promise<R>;
  (message: P, options?: grpc_1.CallOptions): Promise<R>;
}
export abstract class UnimplementedSecretsHealthService {
  static definition = {
    HealthCheck: {
      path: "/secrets.health.v1.SecretsHealth/HealthCheck",
      requestStream: false,
      responseStream: false,
      requestSerialize: (message: dependency_1.SecretsHealthCheckRequest) =>
        Buffer.from(message.serialize()),
      requestDeserialize: (bytes: Buffer) =>
        dependency_1.SecretsHealthCheckRequest.deserialize(
          new Uint8Array(bytes),
        ),
      responseSerialize: (message: dependency_1.SecretsHealthCheckResponse) =>
        Buffer.from(message.serialize()),
      responseDeserialize: (bytes: Buffer) =>
        dependency_1.SecretsHealthCheckResponse.deserialize(
          new Uint8Array(bytes),
        ),
    },
  };
  [method: string]: grpc_1.UntypedHandleCall;
  abstract HealthCheck(
    call: grpc_1.ServerUnaryCall<
      dependency_1.SecretsHealthCheckRequest,
      dependency_1.SecretsHealthCheckResponse
    >,
    callback: grpc_1.sendUnaryData<dependency_1.SecretsHealthCheckResponse>,
  ): void;
}
export class SecretsHealthClient extends grpc_1.makeGenericClientConstructor(
  UnimplementedSecretsHealthService.definition,
  "SecretsHealth",
  {},
) {
  constructor(
    address: string,
    credentials: grpc_1.ChannelCredentials,
    options?: Partial<grpc_1.ChannelOptions>,
  ) {
    super(address, credentials, options);
  }
  HealthCheck: GrpcPromiseServiceInterface<
    dependency_1.SecretsHealthCheckRequest,
    dependency_1.SecretsHealthCheckResponse
  > = (
    message: dependency_1.SecretsHealthCheckRequest,
    metadata?: grpc_1.Metadata | grpc_1.CallOptions,
    options?: grpc_1.CallOptions,
  ): Promise<dependency_1.SecretsHealthCheckResponse> => {
    if (!metadata) {
      metadata = new grpc_1.Metadata();
    }
    if (!options) {
      options = {};
    }
    return new Promise((resolve, reject) =>
      super.HealthCheck(
        message,
        metadata,
        options,
        (
          error: grpc_1.ServiceError,
          response: dependency_1.SecretsHealthCheckResponse,
        ) => {
          if (error) {
            reject(error);
          } else {
            resolve(response);
          }
        },
      ),
    );
  };
}
