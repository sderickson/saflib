# Routes

Routes are the main source in packages which depend on `@saflib/express`. They are strongly typed, using types generated by separate `spec` packages which depend on `@saflib/openapi`.

For clarity, a **route** is the specification. The **handler** (or "route handler") is the implementation.

## File Organization

Route handlers should be organized in directories by their route prefix. For example [identity route handlers](https://github.com/sderickson/saflib/tree/f1864114bbd38b20996ea0dfe486767dff42d3b2/identity/identity-service/routes) are divided into `users` and `auth` folders based on their [OpenAPI-specified paths](https://github.com/sderickson/saflib/blob/f1864114bbd38b20996ea0dfe486767dff42d3b2/identity/identity-spec/openapi.yaml).

Each handler (e.g. get, list, create, update, delete) should reside in its own file per [best practice](../../best-practices.md#keep-files-small).

An `index.ts` file within each domain directory aggregates the individual handlers into an [Express Router](https://expressjs.com/en/5x/api.html#router). This router should include a response from [`createScopedMiddleware`](http://docs.saf-demo.online/express/docs/ref/functions/createScopedMiddleware.html), scoped to the route prefix. The router should handle the entire route path and be able to slot into an Express app without any further path qualification.

> TODO: Update index routers to actually handle the entire route path.

## Typing the Interface

Spec packages provide types for route requests and responses. Every handler must use these types to highlight as quickly as possible when the implementation does not match the specification.

Spec libraries export utility types with API route [operationIds](https://swagger.io/docs/specification/v3_0/paths-and-operations/#operationid) and status codes as keys for easy access. It is up to the handler to use and enforce those types.

Examples:

- [forgot-password.ts](https://github.com/sderickson/saflib/blob/37d619bf41fe2922880dee7483b9fb9690d2ee1b/identity/identity-service/routes/auth/forgot-password.ts)
- [resend-verification.ts](https://github.com/sderickson/saflib/blob/2025-08-13-update-docs/identity/identity-service/routes/auth/resend-verification.ts).

For more information on generating types from the spec, see [@saflib/openapi](../../openapi/docs/01-overview.md).

## Wrapping the Handler

Each handler should be wrapped with [`createHandler`](https://github.com/sderickson/saflib/blob/6070cd5d0bb8d44b7114c0b7dd9b318bd9b1de4a/express/src/handler.ts). It just promisify's the handler, ensuring any uncaught exceptions get passed to `next`. More functionality may be added there such as more advanced typing, instrumentation, so it's important to have this intermediary around all handlers.

## Error Handling

It is up to the handler to have somewhere in it a return for every specified HTTP response code in the spec, except for 401s because those are handled by `@saflib/express`'s middleware. The handler should be the _only_ place where HTTP responses, successful or otherwise, are created or type checked. Essentially, it is the sole responsibility of the HTTP handler function to handle HTTP concerns.

There should be no try/catches in an HTTP handler. All unsafe operations made by the handler should return an error or a response, per [best practices](../../best-practices.md#return-errors). Those errors should be mapped to the appropriate HTTP error response code and body. If any exceptions are thrown, error middleware will catch it and it will be treated appropriately as a 5xx.

Handlers may report errors in any of the following ways:

1. `throw` an error created with [`https-errors`](https://www.npmjs.com/package/http-errors)'s `createError` function.
2. Call `next` with an `http-error` error.
3. Respond directly (`res.status(code).json({} satisfies ResponseBodyType);`), same as for successful responses.

The vast majority of errors responses should simply be [the error object](https://github.com/sderickson/saflib/blob/37d619bf41fe2922880dee7483b9fb9690d2ee1b/openapi/schemas/error.yaml) specified in `@saflib/openapi`. Error middleware will always respond with this structure, and so you can only use 1. and 2. if your spec adheres to the common error response object. If you need a custom error object, you will have to use option 3.

Note that `message` is _for debugging_. The `message` is _not_ intended to be shown to end users as part of normal use; it is not localized. Instead, the frontend should use the HTTP status and, if necessary, the `code` field to decide what to render to the user. The `@saflib/vue` package in fact logs the message and [only propagates](https://github.com/sderickson/saflib/blob/e75a8597ae497ea8d422dab1a1e96f41792b85ba/vue-spa/src/tanstack.ts#L63-L67) the http status and response code fields to Vue components. All SDKs should do the same.

To return a code, include it in the third parameter (the `properties` object, see [docs](https://www.npmjs.com/package/http-errors#createerrorstatus-message-properties)) to `createError`.

```ts
createError(400, "This file type is not supported", {
  code: "FILE_TYPE_NOT_SUPPORTED",
});
```

See for example [get-profile.ts](https://github.com/sderickson/saflib/blob/37d619bf41fe2922880dee7483b9fb9690d2ee1b/identity/identity-service/routes/auth/get-profile.ts).

## File Upload Routes

Routes that accept file uploads need additional setup beyond a standard handler:

1. **Router middleware**: The group's `index.ts` router must pass `fileUploader: uploadToDiskOptions` (from `@saflib/express`) to `createScopedMiddleware` so that multipart requests are parsed by multer.

2. **File container in context**: The service's request-scoped context (usually in the adjacent `-common` package) must include an `ObjectStore` property named `<groupName>FileContainer` (e.g. `recipesFileContainer`). This is created via `@saflib/object-store` and passed into the context. The `express/add-handler` workflow's first step (when `--upload` is set) handles finding or creating this.

3. **`req.files` shape**: Multer may provide `req.files` as an array (`.any()`) or a keyed object (`.fields()`). Handlers should handle both forms and match the field name from the OpenAPI spec (e.g. `"file"`).

4. **Write order**: Create the DB record first (with blob_name, file_original_name, mimetype, size), then upload to the container. On upload failure, delete the DB record and return 500. This ensures partial state is cleaned up.

5. **Delete validation**: For delete handlers on child resources (e.g. deleting a file belonging to a recipe), fetch the record first and validate the parent relationship *before* deleting. This prevents destroying data when the request should return 404.

## Business Logic

Since a route handler is primarily responsible for HTTP concerns, it should house as little business logic as possible. Instead it should call out to:

- Database packages using their provided queries
- Integration packages which interface with external dependencies
- RPC packages which communicate with other internal services

For more complex behaviors whcih do not fall into one of these, consider using one of the following:

- Finite state machines (with `@saflib/xstate`) for complex, asynchronous workflows
- Database packages with transactions for complex query behaviors

Another special mention is transformers. Databases, 1st party services, and 3rd party services have their own models, and those need to be transformed from and into API requests and responses. These should be kept in a separate `transformers/` directory at the root of the package.

> TODO: Properly organize transformer logic in identity-service.

**Warning**: Currently, the largest gap in SAF is a job queue system. Once this is added, most requirements for delegating business logic in most applications should be met.
