import { Logger } from "winston";

/**
 * Auth object passed in with every authenticated request.
 */
export interface Auth {
  userId: number;
  userEmail: string;
  userScopes: string[];
}

/**
 * List of allowed subsystem names to be used as context for logging and such.
 */
export type SubsystemName =
  | "http" // an http server, typically express
  | "grpc" // a grpc server
  | "cron" // a cron process running jobs in the background (no server)
  | "init" // code that's running on startup
  | "cli" // running as part of a CLI command
  | "test"; // running as part of a test;

/**
 * Static, serializable context about what's currently going on.
 * These should always be available in backend systems.
 */
export interface SafContext {
  /**
   * Format: "{uuid}"
   * Generated by request instantiators server-side, so things like reverse proxies, async job services,
   * and http servers which are directly accessible by clients. Generally, grpc and http servers receive
   * a request ID and should use it to correlate requests across processes.
   */
  requestId?: string;

  /**
   * Format: "{service}"
   * e.g. "auth", "payment", "logging", or the name of a product.
   * The name should match the docker service and npm package name (not including the org).
   */
  serviceName: string;

  /**
   * Format: "{subsystem}"
   *
   * Basically, a single server or long-running "process".
   */
  subsystemName: SubsystemName;

  /**
   * Format: "{method_name}"
   * e.g. "GetUser", such as operationId in OpenAPI, rpc name in gRPC, job name in cron, or command name in CLI.
   */
  operationName: string;

  /**
   * If the request is backed by an authenticated user, this will be set.
   * More info should be gotten directly from the auth service.
   */
  auth?: Auth;
}

/**
 * Taken from Sentry, excluding "log" which seems superfluous and vague
 */
export type ErrorLevels = "fatal" | "error" | "warning" | "info" | "debug";

/**
 * Subset of properties given to Sentry or similar error reporting services.
 * https://docs.sentry.io/platforms/javascript/guides/node/apis/#captureException
 *
 * Mainly missing fields that are or should be handled automatically (such as in defaultErrorReporter).
 * - user
 * - contexts
 * - fingerprint
 * - tags
 */
export interface ErrorReportOptions {
  // default: error
  level?: ErrorLevels;
  extra?: Record<string, unknown>;
}

/**
 * The function that application logic has access to for reporting errors.
 */
export type ErrorReporter = (
  error: unknown, // Should be an Error, will throw an error if not
  options?: ErrorReportOptions,
) => void;

/**
 * Parameters provided to error collectors.
 */
export interface ErrorCollectorParam {
  error: Error;

  user?: {
    id: string;
    ip_address?: string;
  };

  level: ErrorLevels;
  extra: Record<string, unknown>;
  tags: Record<string, string | undefined>;
}

/**
 * Collectors take errors reported to them and propagate them to telemetry services such as Sentry.
 */
export type ErrorCollector = (param: ErrorCollectorParam) => void;

/**
 * Clients for reporting various sorts of telemetry. They're expected to be instantiated with a SafContext,
 * so that context is included.
 */
export interface SafReporters {
  /*
   * The generic logger to use for this context. This is for leveled, message logs, for monitoring and debugging.
   */
  log: Logger;

  /*
   *
   */
  logError: ErrorReporter;

  // TODO: Product Events
  // TODO: Errors

  // Note: Metrics and spans are not expected to ever be included here. Libraries and services should
  // instantiate them and use them on their own. However! These reporters are expected to contribute
  // to spans, by adding product events, logs, and exceptions to spans. They don't currently do this, though.
}

/**
 * Convenience type for when the context needs to have auth.
 */
export interface SafContextWithAuth extends SafContext {
  auth: Auth;
}
