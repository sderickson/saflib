import {
  buildMonorepoContext,
  getCurrentPackageName,
  getAllPackageWorkspaceDependencies,
} from "@saflib/dev-tools";
import type { JSONSchema4 } from "json-schema";
import { readFileSync } from "fs";
import { existsSync } from "fs";
import path from "path";
import { compile } from "json-schema-to-typescript";

type JSONSchemaStringSchema = JSONSchema4 & {
  type: "string";
  source: string;
};

interface SimplifiedJSONSchema {
  type: "object";
  properties: Record<string, JSONSchemaStringSchema>;
  required?: string[];
  additionalProperties: false;
}

export const getCombinedEnvSchema = async (targetPackageName?: string) => {
  const context = buildMonorepoContext();

  const currentPackageName = targetPackageName ?? getCurrentPackageName();

  const allDependencies = getAllPackageWorkspaceDependencies(
    currentPackageName,
    context,
  );

  const allPackageNames = Array.from(allDependencies).concat([
    currentPackageName,
  ]);

  const allEnvSchemas: JSONSchema4[] = allPackageNames
    .map((dependency) => {
      const packagePath = context.monorepoPackageDirectories[dependency];
      const envSchemaPath = path.join(packagePath, "env.schema.json");
      if (!existsSync(envSchemaPath)) {
        return null;
      }
      const schema = JSON.parse(
        readFileSync(envSchemaPath, "utf-8"),
      ) as JSONSchema4;
      schema.source = dependency;
      return schema;
    })
    .filter((schema) => schema !== null);

  const combinedSchema: SimplifiedJSONSchema = {
    type: "object",
    properties: {},
    required: [],
    additionalProperties: false,
  };

  allEnvSchemas.forEach((schema: JSONSchema4) => {
    if (schema.type !== "object") {
      throw new Error("Schema is not an object");
    }
    if (schema.properties === undefined) {
      return;
    }
    const simplifiedSchema = schema as SimplifiedJSONSchema;
    Object.entries(simplifiedSchema.properties).forEach(([key, value]) => {
      if (combinedSchema.properties[key] !== undefined) {
        const withSourceStripped = {
          ...combinedSchema.properties[key],
          source: undefined,
        };
        if (JSON.stringify(withSourceStripped) !== JSON.stringify(value)) {
          throw new Error(`Property ${key} is defined in multiple schemas`);
        }
        return;
      }
      combinedSchema.properties[key] = JSON.parse(JSON.stringify(value));
      combinedSchema.properties[key].source = schema.source;
    });
    if (simplifiedSchema.required !== undefined) {
      if (combinedSchema.required === undefined) {
        combinedSchema.required = [];
      }
      combinedSchema.required.push(...simplifiedSchema.required);
    }
  });

  const sortedRequired = Array.from(new Set(combinedSchema.required)).sort();
  const sortedSchema: SimplifiedJSONSchema = {
    type: "object",
    properties: {},
    required: sortedRequired,
    additionalProperties: false,
  };
  const sortedProperties = Object.keys(combinedSchema.properties).sort();
  sortedProperties.forEach((property) => {
    sortedSchema.properties[property] = combinedSchema.properties[property];
  });

  return sortedSchema;
};

export function kebabCaseToPascalCase(str: string) {
  const words = str.split("-");
  return words
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join("");
}

export const makeEnvParserSnippet = async (
  schema: SimplifiedJSONSchema,
  packageName: string,
) => {
  const packageNamePieces = packageName.split("/");
  const lastPiece = packageNamePieces[packageNamePieces.length - 1];
  const pascalCaseLastPiece = kebabCaseToPascalCase(lastPiece);
  const typeName = `${pascalCaseLastPiece}EnvSchema`;

  const typeSnippet = await compile(schema, typeName, {
    bannerComment: `
/**
 * Environment variables for the \`${packageName}\` package, including inherited variables.
 * Generated by \`@saflib/env\`. To update, make changes to the adjacent \`env.schema.json\`, navigate to the package root, and run \`npm exec saf-env generate\`.
 */
`,
  });

  // In edge cases, this code can appear in browser environments, so the globalThis.process check is for that.
  return `${typeSnippet}
/**
 * \`process.env\` casted to the \`${typeName}\` type.
 */
export const typedEnv = (globalThis.process ? process.env : {}) as unknown as ${typeName};
`;
};
